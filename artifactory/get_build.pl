#!/usr/bin/perl

use strict;
use warnings;

use LWP::UserAgent;
use JSON;
use Getopt::Long;

my ($module, $version, $save_as, $save_as_symlink, $print_url_only, $auto_save_as_symlink);
GetOptions(
	'module=s' => \$module,
	'version=s' => \$version,
	'save-as=s' => \$save_as,
	'save-as-symlink=s' => \$save_as_symlink,
	'print-url-only!' => \$print_url_only,
	'auto-save-as-symlink!' => \$auto_save_as_symlink,
);
$module = $ARGV[0] if defined $ARGV[0];
$version = $ARGV[1] if defined $ARGV[1];

my $logger = Logger->new( ! $print_url_only);

if (defined $version) {
	$logger->info("search for module [%s] version [%s]", $module, $version);
	my $info_uri = get_info_uri($logger, $module, $version);
	if (defined $info_uri) {
		my $details = get_details($info_uri);
		(my $name = $details->{'downloadUri'}) =~ s!^.*/!!;
		$logger->info("found [%s], size [%d]", $name, $details->{'size'});
		if ($print_url_only) {
			print $details->{'downloadUri'};
		} elsif (defined $save_as) {
			$logger->info("saving as [%s]", $save_as);
			save_as_file($details->{'downloadUri'}, $save_as);
		} elsif (defined $save_as_symlink || defined $auto_save_as_symlink) {
			if (need_save($logger, $name, $details->{'size'})) {
				$logger->info("saving as [%s]", $name);
				save_as_file($details->{'downloadUri'}, $name);
			} else {
				$logger->info("skip saving [%s] (file with same name and size exists)", $name);
			}
			unless (defined $save_as_symlink) {
				$save_as_symlink = guess_name_without_version($details);
			}
			$logger->info("creating symlink [%s] -> [%s]", $save_as_symlink, $name);
			unlink($save_as_symlink);
			system("ln", "-s", $name, $save_as_symlink);
		}
	} else {
		if ($print_url_only) {
			$logger->print_all_to_stderr();
		}
		exit(1);
	}
} else {
	print <<USAGE;
Usage: $0 <module> <version> [options...]
Version can look like: "1.2.75" or "master".
  Use "release" version to get result of release snapshot.
Options:
  --module=<module>
  --version=<version>
  --save-as=<file-name> - save as file name specified
  --save-as-symlink=<symlink-name> - same artifact as its name and create symbolic link for it (artifact is not downloaded if the same file already exists)
  --print-url-only - only print download link
  --auto-save-as-symlink - the same as --save-as-symlink, but symlink-name is generated by striping version number from artifact name

USAGE
	exit(2);
}

sub guess_name_without_version {
    my ($details) = @_;

	my $extra = "";
	if ($details->{'uri'} =~ m{(jar-with-dependencies|jetty-console)}) {
		$extra = "-".$1;
	}
	my ($name) = ($details->{'uri'} =~ m{com/sesamecom/([^/]+)});
	unless (defined $name) {
		die "can't find original name from [".$details->{'uri'}."]";
	}
	my ($extention) = ($details->{'uri'} =~ m{(\.[^.]+)$});
	unless (defined $extention) {
		die "can't find file extention from [".$details->{'uri'}."]";
	}
	return $name.$extra.$extention;
}

sub need_save {
    my ($logger, $file, $size) = @_;
	
	if (-e $file) {
		my $current_size = (stat($file))[7];
		if ($current_size == $size) {
			return 0;
		} else {
			$logger->info("file [%s] size changed (current %s, new %s)", $file, $current_size, $size);
		}
	}
	return 1;
}
sub get_info_uri {
    my ($logger, $module, $version) = @_;

	if ($version eq 'release') {
		my $result = search($logger, $module, "*-*");
		$result = [ grep {m{\.\d+-\d+\.\d+-\d+}} @$result ];
		my $snapshot = get_newest_snapshot($result);
		if (defined $snapshot) {
			$logger->info("latest snapshot version [%s]", $snapshot);
			my $best_name = get_best_name($logger, [ grep {m{\Q$snapshot}} @$result ]);
			return $best_name;
		}
	} elsif ($version =~ m{^[\d.]+$}) {
		my $result = search($logger, $module, $version);
		my $best_name = get_best_name($logger, $result);
		return $best_name;
	} else {
		my $result = search($logger, $module, $version."*");
		my $snapshot = get_newest_snapshot($result);
		if (defined $snapshot) {
			$logger->info("latest snapshot version [%s]", $snapshot);
			my $best_name = get_best_name($logger, [ grep {m{\Q$snapshot}} @$result ]);
			return $best_name;
		}
	}
	return undef;
}

sub get_newest_snapshot {
    my ($result) = @_;
	
	if (@$result) {
		my %snapshots;
		for my $file (@$result) {
			if ($file =~ m{(\d+\.\d+-\d+)(?!.*\d)}) {
				$snapshots{$1} = 1;
			}
		}
		if (keys %snapshots) {
			return (sort keys %snapshots)[-1];
		} else {
			$logger->info("can't find any snapshot version [%s]", join(', ', map { s!^.*/!!; $_ } @$result));
		}
	}
	return undef;
}	

sub get_best_name {
    my ($logger, $result) = @_;
	
	if (@$result) {
	    my @no_pom = grep {! m{\.pom$}} @$result;
	    if (@no_pom == 1) {
	    	return $no_pom[0];
	    }
	    my @with_dependencies = grep {m{jar-with-dependencies}} @$result;
	    if (@with_dependencies == 1) {
	    	return $with_dependencies[0];
	    }
	    my @jetty_console = grep {m{jetty-console}} @$result;
	    if (@jetty_console == 1) {
	    	return $jetty_console[0];
	    }
	    $logger->info("can't find suitable name from [%s]", join(', ', map { s!^.*/!!; $_ } @$result));
    }
    return undef;
}

sub search {
    my ($logger, $id, $version) = @_;

    my $result = api_call("http://artifactory.sesamecom.com/artifactory/api/search/gavc?g=com.sesamecom&v=".$version."&a=".$id);
    $result //= { 'results' => [] };
    $result = [ map {$_->{'uri'}} @{ $result->{'results'} } ];
    unless (@$result) {
	    $logger->info("no artifacts found");
    }
    return $result;
}

sub get_details {
    my ($uri) = @_;
	
	return api_call($uri);
}

sub api_call {
    my ($url) = @_;
	
	my $ua = get_user_agent();
	my $response = $ua->get($url);
	if ($response->is_success()) {
		return decode_json($response->decoded_content());
	} else {
		if ($response->code() == 404) {
			return undef;
		} else {
			die $response->status_line();
		}
	}
}

sub save_as_file {
    my ($url, $file) = @_;
	
	my $ua = get_user_agent();
	my $response = $ua->get($url);
	if ($response->is_success()) {
		open(my $fh, ">", $file) or die "can't write [$file]: $!";
		binmode($fh);
		print $fh $response->decoded_content();
		close($fh);
	} else {
		die $response->status_line();
	}
}

sub get_user_agent {

	my $ua = LWP::UserAgent->new();
	$ua->default_header("Authorization", "Basic ZGVwbG95OmQzcGwweQ==");
	return $ua;
}

package Logger;

sub new {
    my ($class, $print) = @_;
	
	return bless {
		'print' => $print,
		'lines' => [],
	}, $class;
}

sub info {
    my ($self, $msg) = (shift, shift);
	
	if ($self->{'print'}) {
	    printf $msg."\n", @_;
	} else {
		push(@{ $self->{'lines'} }, sprintf($msg, @_));
	}
}

sub print_all_to_stderr {
    my ($self) = @_;
	
	for my $line (@{ $self->{'lines'} }) {
		print STDERR $line."\n";
	}
	$self->{'lines'} = [];
}
